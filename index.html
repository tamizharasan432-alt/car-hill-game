<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Hill Climber</title>
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}
body {
  overflow: hidden;
  font-family: 'Arial', sans-serif;
}
canvas {
  display: block;
}
#ui {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
}
#hud {
  position: absolute;
  top: 20px;
  left: 20px;
  color: white;
  font-size: 24px;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
  font-weight: bold;
}
#restartBtn {
  position: absolute;
  top: 20px;
  right: 20px;
  padding: 12px 24px;
  font-size: 18px;
  background: #4CAF50;
  color: white;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  pointer-events: auto;
  box-shadow: 0 4px 6px rgba(0,0,0,0.3);
  font-weight: bold;
}
#restartBtn:hover {
  background: #45a049;
}
#restartBtn:active {
  transform: translateY(2px);
}
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="ui">
  <div id="hud">
    <div>Distance: <span id="distance">0</span>m</div>
    <div>Best: <span id="best">0</span>m</div>
  </div>
  <button id="restartBtn">Restart</button>
</div>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const distanceEl = document.getElementById('distance');
const bestEl = document.getElementById('best');
const restartBtn = document.getElementById('restartBtn');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

window.addEventListener('resize', () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
});

const GRAVITY = 0.6;
const WHEEL_RADIUS = 20;
const CAR_WIDTH = 80;
const CAR_HEIGHT = 40;
const ACCELERATION = 0.4;
const BRAKE_FORCE = 0.3;
const MAX_SPEED = 12;
const JUMP_FORCE = 15;
const TERRAIN_SEGMENT = 30;

let car = {
  x: 200,
  y: 200,
  vx: 0,
  vy: 0,
  angle: 0,
  wheelAngle: 0,
  onGround: false
};

let camera = { x: 0, y: 0 };
let terrain = [];
let distance = 0;
let bestDistance = parseInt(localStorage.getItem('hillClimberBest') || '0');
let keys = {};

bestEl.textContent = bestDistance;

class Random {
  constructor(seed) {
    this.seed = seed;
  }
  next() {
    this.seed = (this.seed * 9301 + 49297) % 233280;
    return this.seed / 233280;
  }
}

function generateTerrain() {
  terrain = [];
  const rng = new Random(54321);
  let y = canvas.height * 0.6;
  
  for (let i = 0; i < 800; i++) {
    const x = i * TERRAIN_SEGMENT;
    const wave1 = Math.sin(i * 0.03) * 80;
    const wave2 = Math.cos(i * 0.08) * 50;
    const noise = (rng.next() - 0.5) * 30;
    y = canvas.height * 0.6 + wave1 + wave2 + noise;
    terrain.push({ x, y });
  }
}

function getTerrainY(x) {
  const index = Math.floor(x / TERRAIN_SEGMENT);
  if (index < 0) return terrain[0].y;
  if (index >= terrain.length - 1) return terrain[terrain.length - 1].y;
  
  const p1 = terrain[index];
  const p2 = terrain[index + 1];
  const t = (x - p1.x) / TERRAIN_SEGMENT;
  return p1.y + (p2.y - p1.y) * t;
}

function getTerrainAngle(x) {
  const index = Math.floor(x / TERRAIN_SEGMENT);
  if (index < 0 || index >= terrain.length - 1) return 0;
  
  const p1 = terrain[index];
  const p2 = terrain[index + 1];
  return Math.atan2(p2.y - p1.y, p2.x - p1.x);
}

function resetGame() {
  car = {
    x: 200,
    y: 200,
    vx: 0,
    vy: 0,
    angle: 0,
    wheelAngle: 0,
    onGround: false
  };
  camera = { x: 0, y: 0 };
  distance = 0;
  generateTerrain();
}

function update() {
  const accelerating = keys['ArrowRight'];
  const braking = keys['ArrowLeft'];
  const jumping = keys[' '];
  
  if (accelerating) {
    car.vx += ACCELERATION;
  }
  if (braking) {
    car.vx -= BRAKE_FORCE;
  }
  if (jumping && car.onGround) {
    car.vy = -JUMP_FORCE;
  }
  
  car.vx = Math.max(-MAX_SPEED, Math.min(MAX_SPEED, car.vx));
  car.vx *= 0.98;
  
  car.vy += GRAVITY;
  
  car.x += car.vx;
  car.y += car.vy;
  
  const wheelLeftX = car.x - CAR_WIDTH / 2;
  const wheelRightX = car.x + CAR_WIDTH / 2;
  const wheelY = car.y + CAR_HEIGHT / 2;
  
  const groundLeftY = getTerrainY(wheelLeftX);
  const groundRightY = getTerrainY(wheelRightX);
  
  const leftContact = wheelY + WHEEL_RADIUS > groundLeftY;
  const rightContact = wheelY + WHEEL_RADIUS > groundRightY;
  
  car.onGround = leftContact || rightContact;
  
  if (leftContact) {
    const overlap = (wheelY + WHEEL_RADIUS) - groundLeftY;
    car.y -= overlap * 0.5;
    car.vy *= -0.3;
  }
  
  if (rightContact) {
    const overlap = (wheelY + WHEEL_RADIUS) - groundRightY;
    car.y -= overlap * 0.5;
    car.vy *= -0.3;
  }
  
  if (car.onGround) {
    const targetAngle = getTerrainAngle(car.x);
    car.angle += (targetAngle - car.angle) * 0.15;
  }
  
  car.wheelAngle += car.vx * 0.15;
  
  if (car.y > canvas.height + 300) {
    resetGame();
  }
  
  camera.x += (car.x - canvas.width / 2 - camera.x) * 0.1;
  camera.y += (car.y - canvas.height * 0.5 - camera.y) * 0.1;
  
  distance = Math.max(distance, Math.floor(car.x / 10));
  distanceEl.textContent = distance;
  
  if (distance > bestDistance) {
    bestDistance = distance;
    localStorage.setItem('hillClimberBest', bestDistance);
    bestEl.textContent = bestDistance;
  }
}

function render() {
  const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
  gradient.addColorStop(0, '#87CEEB');
  gradient.addColorStop(1, '#E0F6FF');
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  ctx.save();
  ctx.translate(-camera.x, -camera.y);
  
  ctx.fillStyle = '#8B7355';
  ctx.strokeStyle = '#654321';
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(terrain[0].x, canvas.height + camera.y + 500);
  terrain.forEach(point => {
    ctx.lineTo(point.x, point.y);
  });
  ctx.lineTo(terrain[terrain.length - 1].x, canvas.height + camera.y + 500);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
  
  ctx.save();
  ctx.translate(car.x, car.y);
  ctx.rotate(car.angle);
  
  ctx.fillStyle = '#E74C3C';
  ctx.strokeStyle = '#C0392B';
  ctx.lineWidth = 3;
  ctx.fillRect(-CAR_WIDTH / 2, -CAR_HEIGHT / 2, CAR_WIDTH, CAR_HEIGHT);
  ctx.strokeRect(-CAR_WIDTH / 2, -CAR_HEIGHT / 2, CAR_WIDTH, CAR_HEIGHT);
  
  ctx.fillStyle = '#3498DB';
  ctx.fillRect(-15, -CAR_HEIGHT / 2 + 5, 30, 15);
  
  ctx.restore();
  
  function drawWheel(x, y) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(car.wheelAngle);
    
    ctx.fillStyle = '#2C3E50';
    ctx.beginPath();
    ctx.arc(0, 0, WHEEL_RADIUS, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.strokeStyle = '#34495E';
    ctx.lineWidth = 3;
    ctx.stroke();
    
    ctx.strokeStyle = '#7F8C8D';
    ctx.lineWidth = 2;
    for (let i = 0; i < 6; i++) {
      const angle = (i / 6) * Math.PI * 2;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(Math.cos(angle) * WHEEL_RADIUS, Math.sin(angle) * WHEEL_RADIUS);
      ctx.stroke();
    }
    
    ctx.restore();
  }
  
  const cos = Math.cos(car.angle);
  const sin = Math.sin(car.angle);
  
  const wheelLeftX = car.x + cos * (-CAR_WIDTH / 2) - sin * (CAR_HEIGHT / 2);
  const wheelLeftY = car.y + sin * (-CAR_WIDTH / 2) + cos * (CAR_HEIGHT / 2);
  const wheelRightX = car.x + cos * (CAR_WIDTH / 2) - sin * (CAR_HEIGHT / 2);
  const wheelRightY = car.y + sin * (CAR_WIDTH / 2) + cos * (CAR_HEIGHT / 2);
  
  drawWheel(wheelLeftX, wheelLeftY);
  drawWheel(wheelRightX, wheelRightY);
  
  ctx.restore();
}

function gameLoop() {
  update();
  render();
  requestAnimationFrame(gameLoop);
}

window.addEventListener('keydown', e => {
  keys[e.key] = true;
});

window.addEventListener('keyup', e => {
  keys[e.key] = false;
});

restartBtn.addEventListener('click', resetGame);

generateTerrain();
gameLoop();
</script>
</body>
</html>
